{
    "title":"An Introduction to Design Patterns",
    "slidesid":"From the Design Corner"
}


${slide:title=Goal}$


- What are design patterns?
- Why?
- Patterns are not panacea 
- Example

${slide:title=From an architectural 'failure'}$

Christoffer Alexander, 'The Timeless Way of Building', Oxford University Press, 1979
- tried to let people capture and use patterns how to build houses and other
- developed patterns and pattern languages
- basically failed in architecture but the idea is successful for software engineering


${slide:title=Design Patterns}$

- Identification of similar problems at design level
- Experts solved recurring problems in similar ways
- Design patterns are recurrent solutions to design problems
- There are pros and cons
- Design Patterns are literature: ""Read"" them 

${slide:title=What are design patterns?}$

- Elegant solutions that a novice would not think of
- Generic
- Independent on specific system type, language
- Well-proven
--Successfully tested in several systems
- Simple
- Can be combined for more complex solutions

${slide:title=Watchout!}$

There are really stupid patterns (e.g., supersuper) in some books

${slide:title=Most important point}$

- Design Patterns are ""names""
- They create a design ""vocabulary""
-- Hook and Template, Factory, Composite, Visitor, Observer, Decorator...
- You can talk at lunch/blackboard about your design in an ""abstract but precise"" way

${slide:title=What Design Patterns are not}$

- A design pattern is not ""one"" implementation
- A design pattern is ""illustrated"" using one possible implementation 
- But may be alternate implementations are better

${slide:title=Elements of a pattern}$

- ""Pattern name"": Increase of design vocabulary
- ""Pattern intent"": Describe the goal
- ""Problem description"": When to apply it, in what context to use it
- ""Solution description"" (generic !):
-- The elements that make up the design, 
-- their relationships, responsibilities, and collaborations
- ""Consequences"": Results and trade-offs of applying the pattern


${slide:title=Example: Strategy}$

""Intent:"" 
- Define a family of algorithms, 
- encapsulate each in a separate class and 
- define each class with the ""same"" interface so that they can be interchangeable.

${slide:title=Essence of Strategy possible implementation}$

+.>file://figures/DP-Strategy.pdf|width=80+

- Variation: Do we pass the user to the strategy?

${slide:title=Strategy application}$

+.>file://figures/DP-StrategyExample.pdf|width=80+

${slide:title=Some pattern categories}$

- Creational Patterns
--Instantiation and configuration of classes and objects
- Structural Patterns
-- Usage of classes and objects in larger structures, separation of interfaces and implementation
- Behavioral Patterns
-- Algorithms and division of responsibility
- Concurrency
- Distribution
- Security

${slide:title=Some Books}$

- GoF (Gang of Four) Design Patterns (Gamma et al)
- Refactorings to Patterns
- Smalltalk Design Pattern Companion  (excellent)

${slide:title=Some Books}$

+.>file://figures/DP-books.png|width=100+


${slide:title=Some creational patterns}$

- ""Abstract factory""
- Builder
- Factory Method
- Prototype
- ""Singleton"" (Watch out most people get it wrong)

${slide:title=Some structural patterns}$

- Adapter
- Bridge
- ""Composite""
- Decorator
- Façade (arghhhhhhh it is a plague from procedural thinking)
- ""Flyweight""
- Proxy

${slide:title=Some structural patterns}$

- Chain of responsibility
- """Command"""
- Interpreter
- Iterator
- Mediator
- Memento
- Observer
- State
- ""Strategy""
- ""Template Method""
- ""Visitor""


${slide:title=Alert!!!}$

- Design Patterns may be a real plague!
- Do not apply them when you do not need them
- Design Patterns make the software more complex
- More classes
- More indirections, more messages
- Try to understand when NOT applying them!

${slide:title=Alert2 !!!}$

- Do not confuse intent and implementation
- Patterns are about intent and tradeoffs

${slide:title=Conclusion}$

- Reusable solutions to common problems based on experiences from real systems
- Names of abstractions above class and object level a common vocabulary for developers
- Can handle functional and non-functional aspects
-- separating interfaces/implementation, loose coupling between parts, …
- A basis for frameworks and toolkits basic elements to improve reuse
